.\" groff -p -mm %s
.\" Copyright (c) 2016, Lawrence Livermore National Security, LLC. Produced
.\" at the Lawrence Livermore National Laboratory.  Written by Lee Busby,
.\" busby1@llnl.gov. LLNL-CODE-702338. All rights reserved.
.\" See ../../Copyright for additional notices.
.de TP
.sp 5
..
.VM 0 1
.de CR
\f[CR]\s-1\\$1\s+1\fP
..
.PH ""
.PF "'L. Busby'%'6Sep2018'"
.S 11 13
.de VS
\f[CB]\s-2
.in +0.25i
.nf
..
.de VE
.in -0.25i
\fR\s+2
.fi
..
.nr Ec 1
.de EX
.ce
.sp 0.1i
\fBExample \\n(Ec. \\$1\fP
.nr Ec +1
..
.DS C
.S +2
An \f[BI]Intermediate Representation\fP for Structured Input
.S -2
.DE
.H 1 "Abstract"
The \fIIntermediate Representation\fP
(or \fIIR\fP or \fIIREP\fP)
is a tool to simplify reading some kinds of external program input,
a means to organize the input into native language structures,
and a way to share those structures among program modules
written in either C/C++ or Fortran.
It can handle several varieties of ``Plain Old Data''
and has mechanisms to extend its abilities beyond POD.
It requires access to a Lua 5.1 interpreter,
C and Fortran compilers,
and follows standards for those languages.
A reader for tables written in the \fILua\fP programming language
is included.
.H 1 "Introduction"
.H 2 "Sharing Data Among Lua, C/C++ and Fortran"
.P
Lua tables
and constructors
are a flexible way to define program input.
It is usually easy to roughly map a Lua table into structured data types
for C/C++ and Fortran:
.DS
.VS
  Lua             C/C++                   Fortran
\l'6.0i'
t = {           typedef struct irt_t {   type, bind(c) :: irt_t
  a = 1,          int a;                   integer(c_int) :: a = 1
  b = {2.2,3.3},  double b[2];             real(c_double) :: b(2)
  c = "foo",      char c[16];              character(c_char) :: c(16)
  d = true,       _Bool d;                 logical(c_bool) :: d = .true.
}               } irt_t;                 end type irt_t
.VE
.DE
.P
This works best for, but is not strictly limited to,
``Plain Old Data'' (POD).
For our purposes,
\fIPOD\fP is a scalar variable or 1D vector of
type \fIinteger\fP, \fIdouble\fP, \fIstring\fP, or \fIboolean\fP.
.P
The Fortran \fIISO_C_BINDING\fP lets us map structures
between C/C++ and Fortran.
The C pre-processor specifies the IR in a language-neutral way.
Here is the same structure as above,
written using the IR macros:
.DS
.VS
Beg_struct(irt_t)      Doc(( Begin structure declaration ))
   ir_int(a,1)         Doc(( Scalar integer with default value = 1 ))
  Vir_dbl(b,2,3.0)     Doc(( Vector double, 2 elements, default = 3.0 ))
   ir_str(c,16,"foo")  Doc(( Scalar string, maxlen=16, default = "foo" ))
   ir_log(d,true)      Doc(( Scalar boolean, default = true ))
End_struct(irt_t)      Doc(( End structure ))
.VE
.DE
Structures in the IR are defined in a C header.
When the file is included from C/C++ source,
the macros output a C/C++ \fIstruct\fP declaration.
From Fortran,
the output is the equivalent \fIderived type\fP.
The Fortran version \fIdefines\fP and initializes the structures,
while C/C++ \fIdeclares\fP them as \fIextern\fP objects.
There is one shared instance of any IR variable in the data
segment of a running program.
.H 2 "Nested Tables"
.P
The IR includes a \f[CB]\s-2Structure\s+2\fP macro
to allow nested C/C++ and Fortran structures:
.DS
.VS
  IREP                  C/C++            Fortran
\l'5.0i'
Beg_struct(irt_T1)      ...              ...
  Structure(irt_T2,x)   irt_T2 x;        type(irt_T2) :: x
End_struct(irt_T1)      ...              ...
.VE
.DE
Nested structures follow C ordering rules: \fIirt_T2\fP must be
declared before \fIirt_T1\fP, etc.
.H 2 "Using IR Data in the Host Code"
.P
After the IR has been defined and compiled,
and after data has been read from the Lua input file into the IR,
the host code can access data using native language operations:
.DS
.VS
-- First, set the value by reading the Lua table.
material[1].EOS.table.number = 1018
.sp 0.05i
// Later, read the value from C/C++.
int n = material[1].EOS.table.number; // 1018
.sp 0.05i
! Or read the value from Fortran.
integer :: n
n = material(1)%EOS%table%number ! 1018
.VE
.DE
Notice that the example above uses index ``1'' for all three
languages.
This is a consequence of the way that the \fImaterial\fP
table was declared in the IREP.
See the discussion of the \fIVir_wkt\fP macro in the IREP
man page that accompanies this paper for more information.
.H 2 "Reading Data Into the IR"
.P
The compiled \fIdata store\fP in
the IR is independent of any means to
load or change its values.
We provide a Lua table reader for that purpose.
If the IR data store defines a top-level structure named \fImaterial\fP,
as in the example above,
we expect the Lua input to contain a global table also named \fImaterial\fP,
and call this a \fIwell known table\fP (WKT).
The elements of the Lua table must match the elements of the IR
structure.
Whenever the Lua reader reaches a leaf node in its table,
it looks up the address of the matching IR element,
and places the value at that memory location.
.H 1 "Designing the User Interface"
.P
Lua tables and Lua variables can be quite different
from C/C++ or Fortran structures and variables.
Here are some Lua idioms that are difficult to model in the IR data store:
.AL
.LI
Polymorphic element values:
Lua is happy to allow both ``x=1'' and ``x="one"'' (at different times)
in the same table.
This is hard to do in the IR,
because C/C++ and Fortran variables can't change type.
One place where we do allow polymorphic elements is
our implementation of callback functions:
.DS
.VS
f = 3
f = { 1, 2, 3 } -- max len is 9 elements
f = function() return 3 end
.VE
.DE
We frequently use \fIconstant\fP callback functions,
so it is convenient to allow scalar or array values
in place of a true Lua function,
as shown in the first two examples above.
Callback functions require some special handling already,
so this case does not present much extra trouble for the Lua reader.
In general, however,
it's a good idea to limit polymorphic elements in the
user interface.
.LI
Lua tables with both record and array parts:
.DS
.VS
a = { 3,2,1, x=4 }
.VE
.DE
That is, ``a[1] == 3'', and ``a.x == 4''.
There is no easy way to handle this case with the IR,
because ``a'' is neither a vector, nor is it a structured type.
It's some of both.
Don't do this,
or use an \fIir_reference\fP if you must.
.LI
Lua arrays with mixed types:
.DS
.VS
a = { 3,2,1, "liftoff" }
.VE
.DE
In this case, ``a'' is a vector, but its elements don't
have any single type.
Arrays in C/C++ and Fortran cannot have elements
of more than one type.
So don't do this either.
.LE
.P
In designing the user interface,
we can choose, case by case,
whether to let the constraints imposed by the IR
also constrain or shape the Lua interface.
By its nature, the IR rewards simplicity in user interface design.
.H 1 "Some Usage Notes"
.H 2 "The \f[BI]ir_read\fP and \f[BI]ir_exists\fP Functions"
.P
In addition to defining IR input data,
the host code is responsible for reading the well known tables.
The function provided for this task is \fIir_read\fP.
For example, in C, we might read the \fImaterials\fP table:
.DS
.VS
int n = ir_read(L, "materials");
if (n != 0) { printf("ERROR: %d\\n", n); exit(1); }
.VE
.DE
Ir_read returns the total number of errors it encountered.
For well known tables that may be optional,
the \fIir_exists\fP function is provided to allow the host code
to query whether a given table element is in the Lua state before
attempting to read it.
.H 2 "Strings"
.P
Sharing strings between Fortran and C/C++ is easier than it once was.
That said,
reading strings from the IR requires extra care for both languages.
Strings are stored in the IR as an array of characters,
NULL delimited.
The max length is part of the original declaration,
and it includes the NULL character.
The IR provides convenience functions and macros to
simplify some common operations:
.DS
.VS
std::string myfoo(IR_STR(t.c));    // C++: Declare/initialize.
character(len=64) :: myfoo         ! Fortran: Declare scalar.
myfoo = trim(fstr(IR_STR(t.c))) ! Initialize it.
.VE
.DE
