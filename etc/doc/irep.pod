=head1 NAME

=begin comment

# Copyright (c) 2016, Lawrence Livermore National Security, LLC. Produced
# at the Lawrence Livermore National Laboratory.  Written by Lee Busby,
# busby1@llnl.gov. LLNL-CODE-702338. All rights reserved.
# See ../../Copyright for additional notices.

=end comment

IREP - An I<Intermediate Representation> for Structured Input

=head1 SYNOPSIS

  // C/C++
  #include "ir_extern.h"
  #include "wkt_TABLE.h"

  int ir_read(lua_State *L, const char *tbl_elem);
  int ir_exists(lua_State *L, const char *t);
  int ir_rtlen(lua_State *L, const char *s);

  ! Fortran
  use ir_readnml
  use wkt_TABLE

  integer(c_int) function ir_read(L, t) bind(c, name="ir_read")
    use iso_c_binding
    type(c_ptr), value :: L
    character(kind=c_char), dimension(*) :: t
  end function
  integer(c_int) function ir_exists(L, t) bind(c, name="ir_exists")
    use iso_c_binding
    type(c_ptr), value :: L
    character(kind=c_char), dimension(*) :: t
  end function
  integer(c_int) function ir_rtlen(L, t) bind(c, name="ir_rtlen")
    use iso_c_binding
    type(c_ptr), value :: L
    character(kind=c_char), dimension(*) :: t
  end function

=head1 DESCRIPTION

The I<IREP> is a toolkit and associated C library,
to read Lua tables into a compiled I<data store>.
The toolkit defines the data store as a set of structured variables
in C/C++ and Fortran.
The library reads Lua tables,
comparing table keys with the corresponding variable in the data store,
and puts the table values into the data store.

=head2 Usage

The first step is to design and define one or more I<well-known tables>
for the data store (see below.)
After creating the well-known tables,
you can build the IREP library,
and link it to your C/C++ and/or Fortran code - the I<host code>.

Your host code reads Lua tables into the data store:

  int nerr = ir_read(L, "mytable");

You can access a variable from C<mytable> using native language
operations in the host code:

  // C
  #include "wkt_mytable.h"
  int n = mytable.subtable.n;

  // C++ (The IREP datastore is in namespace "irep".)
  #include "wkt_mytable.h"
  int n = irep::mytable.subtable.n;

  ! Fortran
  use wkt_mytable
  integer n
  n = mytable%subtable%n

You can query the Lua table to discover whether a particular element
actually was given in the input:

  int e = ir_exists(L, "mytable.subtable.n");
  if (e) printf("User input explicitly defines N\n");
  else   printf("Using IREP default value for N\n");

If a table element is a vector,
you can ask how long the actual input array was:

  int nelem = ir_rtlen(L, "mytable.subtable.v1");
    
If a table element is a string,
you can move it from the data store into a local copy using
a macro or function from IREP:

  // C
  char *ss = strndup(IR_STR(t.ss));         // Access scalar string.
  char *vs = strndup(IR_STR(t.vs[0]));      // First element of vector.

  // C++
  std::string my_ss(IR_STR(irep::t.ss));    // Access scalar string
  std::string my_vs(IR_STR(irep::t.vs[0])); // First element of vector.

  ! Fortran
  character(len=64) :: my_ss, my_vs
  my_ss = trim(ir_fstr(t%ss))               ! Access scalar string.
  my_vs = trim(ir_fstr(t%vs(:,1)))          ! First element of vector.

=head2 Defining the Data Store

The IREP data store is a collection of C/C++ C<structs>
and their equivalent Fortran C<derived type>.
The code defining each variable in the data store is written once,
using cpp(1) macros that expand into either C/C++ or Fortran
source code,
depending on the context:

=head3 Example Table in the IREP Data Store

  IREP Input           C/C++ Output     Fortran Output
  -----------------------------------------------------------------
  Beg_struct(irt_t)    struct irt_t {   type, bind(c) :: irt_t
    ir_int(a,1)          int a;           integer(c_int) :: a
    Vir_dbl(b,2)         double b[2];     real(c_double) :: b(2)
    ir_str(c,8,"foo")    char c[8];       character(c_char) :: c(8)
    ir_log(d,true)       _Bool d;         logical(c_bool) :: d
  End_struct(irt_t)    } irt_t;         end type irt_t

The rules for constructing the IREP data store are precisely the
standards for C and Fortran,
as constrained by the Fortran C<ISO_C_BINDING>.
Structures can be nested in arbitrary fashion.
Scalar and one-dimensional array variables (vectors) of type integer,
double, boolean, or character (strings) can be defined.

=head3 Summary of IREP Macros

=over

=item Beg_struct(ID)

Begin declaration for a table named I<ID>.

=item End_struct(ID)

End declaration for a table named I<ID>.

=item ir_wkt(T,ID)

B<Define> a table named I<ID>, with typename I<T>.

=item Structure(T,ID)

B<Declare> a table named I<ID>, with typename I<T>.

=item Vstructure(T,ID,FB,CB)

Declare a vector of tables I<ID>, typename I<T>.
The vector has Fortran bounds I<FB> and C bounds I<CB>.
E.g., if FB=``0:5'', and CB=``6'', the vector will have
six elements indexed from zero to five.

=item ir_dbl(ID,DV)

Declare scalar variable of type double named I<ID>, default value I<DV>.

=item ir_int(ID,DV)

Declare scalar variable of type integer named I<ID>, default value I<DV>.

=item ir_log(ID,DV)

Declare scalar variable of type boolean named I<ID>, default value I<DV>.

=item ir_str(ID,LEN,DV)

Declare scalar string named I<ID>, max len I<LEN>, default value I<DV>.

=item Vir_dbl(ID,NELEM,DV)

Declare vector variable of type double named I<ID>,
with I<NELEM> elements, default value I<DV>.

=item Vir_int(ID,NELEM,DV)

Declare vector variable of type integer named I<ID>,
with I<NELEM> elements, default value I<DV>.

=item Vir_log(ID,NELEM,DV)

Declare vector variable of type boolean named I<ID>,
with I<NELEM> elements, default value I<DV>.

=item Vir_str(ID,LEN,NELEM)

Declare vector string named I<ID>, with I<NELEM> elements, max len I<LEN>.
Note that string vectors cannot set a default value.

=item Callback_dd(ID)

Declare callback function named I<ID>.

=back

=head3 Callback Functions

Along with a declaration in the data store,
callback functions are also entered into the callback table C<cbf_tbl>,
in F<ir_special.h>.
That table records three pieces of information for each function,
or group of related functions:
A I<pattern> matching the fully-qualified function name,
the number of parameters C<nprm>,
and the number of return values C<nret>.
Parameters and return values are all assumed to be of type double
in this implementation.
For example:

  { "^table1.table2[?*].f2$",      3, 1 },

describes a callback function whose basic name is C<f2>,
located inside a table named C<table2>,
which is itself an array inside a top-level
table named C<table1>.
The pattern is a simple regular expression,
anchored at the beginning and end with ``^'' and ``$'',
respectively.
It would match
C<table1.table2[3].f2>,
or
C<table1.table2[57].f2>,
but not 
C<table1.table2.foo.f2>.
(The construction ``?*'' means one or more of any single character.)

=head2 Reading a Well Known Table

The host code finds and loads (compiles) Lua input using
the normal C<luaL_loadfile>, C<lua_pcall> sequence.
If the Lua input contains a well-known table named,
say, C<tab1>,
that table can be read into the IREP data store using the call:

  int n = ir_read(L, "tab1");

This recursively reads the entire table.
If C<tab1> itself contains a subtable C<tab2>,
that table could be individually read as:

  int n = ir_read(L, "tab1.tab2");

That is, C<ir_read> can start at any point in a Lua table,
and reads recursively from that element down.
The syntax of the second argument is equivalent to the Lua
syntax that would reference the same element.
Reading just the subtable ignores elements in C<tab1>
that are outside of C<tab2>.

=head2 Special Handling

A well-known table in the Lua input is normally mirrored
exactly by its counterpart in the IREP data store.
A given,
fully-qualified key name in the Lua table
is matched component by component with the data store,
and the ultimate I<value> for that key is matched against
the type and size of the data store variable.
If the match is perfect,
(same type,
and size of Lua element <= size of the IREP variable)
the assignment succeeds.
If not,
we presume the Lua input is faulty,
and record an error.

Special handling is a way to work around the ``perfect match''
requirement.
The implementation is similar to the way that callback functions
are handled.
There is a table in F<ir_special.h> named C<sh_tbl>,
where we record a I<pattern> and a handler function for it.
If the pattern is encountered,
control is passed to the handler function for that pattern.
One particular special handler is provided by the implementation:
C<ir_ignore> will ignore a table element that matches the given
pattern.
This effectively gives the host code latitude to read most,
but not all,
of a table using C<ir_read>,
and read (or ignore) the remainder using some other means.

=head1 RETURN VALUE

C<ir_read> returns the number of errors encountered.

C<ir_exists> returns 1 if the element is found in the Lua input,
0 if not.

C<ir_rtlen> returns -1 if the given Lua value is not present,
0 if the value is a (scalar) number,
or whatever C<lua_objlen> returns otherwise.
For a string,
this is the length of the string.
For an array,
it is the same as the ``#'' operator in Lua.

=head1 BUGS

All variables in the IREP data store are static.
This is a consequence of current ISO_C_BINDING rules
for sharing data between Fortran and C.
This means that the maximum length of arrays (and therefore strings)
in the IREP data store
is fixed at compile time.

=head1 AUTHOR

Written by Lee Busby,
Lawrence Livermore National Laboratory.

=head1 COPYRIGHT

Copyright (c) 2016, Lawrence Livermore National Security, LLC.
See the file named "Copyright" for the full text of the copyright notice.

=head1 SEE ALSO

See the example code which accompanies this release,
located at F<etc/ex1> (C) and F<etc/ex2> (Fortran).
This code illustrates how to construct a I<well-known table>,
how to build and link the IREP library,
how to write Lua input matching the WKT,
and how to access the compiled data store from the host code.

See F<irep-guide>,
in this directory,
for more discussion of some of the code in IREP.
In particular,
special handling is covered in greater depth.

=cut
