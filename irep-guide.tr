.\" groff -t -p -mm %s
.\" Copyright (c) 2016, Lawrence Livermore National Security, LLC. Produced
.\" at the Lawrence Livermore National Laboratory.  Written by Lee Busby,
.\" busby1@llnl.gov. LLNL-CODE-702338. All rights reserved.
.\" See ../../Copyright for additional notices.
.de TP
.sp 5
..
.VM 0 1
.de CR
\f[CR]\s-1\\$1\s+1\fP
..
.PH ""
.PF "'L. Busby'%'11 August 2016'"
.S 12 14
.de VI
\f[CI]\s-2
.in +0.25i
.nf
..
.de VB
\f[CB]\s-2
.in +0.25i
.nf
..
.de VE
.in -0.25i
\fR\s+2
.fi
..
.nr Ec 1
.de EX
.ce
.sp 0.1i
\fBExample \\n(Ec. \\$1\fP
.nr Ec +1
..
.DS C
.S +2
A Programming Guide to the IREP
.S -2
.DE
.H 1 "Introduction"
.P
The core of the \fIIntermediate Representation\fP \- IREP \-
is less than 400 lines of code and header files.
However, it combines ideas
and techniques from C,
C++, Fortran, the Lua C library, the C preprocessor,
and the Fortran ISO_C_BINDING.
Interaction with Lua's stack-oriented C library is a key aspect.
Stacks are conceptually simple,
but they can be difficult to visualize and reason about.
Reading the code in IREP can be done in one sitting;
it may be useful to review some key ideas here ahead of time.
.H 1 "Three Parts: Front End, Back End, Assignment Parser"
.H 2 "Front End"
.P
The IR is organized around three components:
The \fIfront end\fP is a generic Lua table reader,
written in C,
which has no knowledge of any table's structure or contents.
Given an input table written in the Lua language,
it outputs a list of strings in some arbitrary order.
Each string ``looks like''
an assignment statement in the Fortran language:
.DS
.VB
LUA INPUT             FRONT END OUTPUT
---------             ----------------
t = {
  a = 3,              "t%a = 3"
  b = { 7.2, 3.5 },   "t%b(1) = 7.2"; "t%b(2) = 3.5"
  s = "abc",          "t%s = 'a','b','c'"
}
.VE
.EX "The IREP front end, input and output"
.DE
.H 2 "Back End"
.P
The IR \fIback end\fP is effectively a set of statically declared
C structs,
each of which contains components that are roughly isomorphic
in name and type to the elements in a given Lua table:
.DS
.VB
struct irt_t {
  int a;
  double b[2];
  char s[16];
} irt_t;
.VE
.EX "The Back End Structure for the Lua Table in Ex. 1"
.DE
The back end actually defines both C/C++ and Fortran structures,
shared using the Fortran ISO_C_BINDING module.
The structures for each language are built from one source form,
written using a small set of \fIcpp\fP (C preprocessor) macros.
.H 2 "Assignment Parser"
.P
The front and back ends are connected with an \fIassignment parser\fP,
which takes the strings produced by the front end as input.
The parser has no \fIa priori\fP information about its input.
It parses each string as a Fortran assignment statement,
and places the assigned value into the matching element in the back end.
If no matching element can be found, it is an error.
That is, a front end element that \fImatches\fP a back end slot
is the definition of \fIcorrect\fP input.
So the parser uses the back end
as a \fItemplate\fP to determine correctness,
and as a storage location for correct values.
.\" ======================================================================
.H 1 "The Front End in Detail"
.P
When the host code (either C/C++ or Fortran) wants to read a
Lua table into the IR,
it calls \fIir_read\fP,
which reads the table and returns the number of errors encountered:
.DS
.VB
int nerr = ir_read(L, "t"); // Read table from Ex. 1.
.VE
.DE
.P
If \fInerr\fP is zero upon return,
then all the entries present in that table
matched a slot in the back end.
\fIIr_read\fP initializes the Lua stack,
initializes the string representation of the requested table element,
and calls the internal reader \fIiir_read\fP.
.P
\fIIir_read\fP works recursively.
It begins execution with a table element
\- an entire table, a subtable, or a scalar key/value pair \-
on top of the Lua stack,
and the name of the element \- a string \-
in a variable of type \fIsbuf_t\fP \- the string representation.
If the element is scalar,
its name and value are passed to the assignment parser,
and the result is returned.
If the element is a (sub)table,
it is opened.
Then each element of the subtable is pushed onto the Lua stack,
its name is appended to the string representation,
and \fIiir_read\fP calls itself recursively.
.P
Below are the logical operations to read the table of Example 1.
\fIRead(t)\fP initializes the stack and string representation.
Each \fIpush\fP adds an element to the stack and string rep,
and recurses.
Each \fIpop\fP removes an element from the stack and string rep,
and calls the assignment parser.
.DS
.TS
box,expand;
llll.
Operation	Lua Stack	String Representation	Output to Parser
_
read(t)	t	"t"	\-
push(a)	a \(bv t	"t%a"	\-
pop(a)	t	"t"	"t%a = 3"
push(b)	b \(bv t	"t%b"	\-
push(1)	1 \(bv b \(bv t	"t%b(1)"	\-
pop(b[1])	b \(bv t	"t%b"	"t%b(1) = 7.2"
push(2)	2 \(bv b \(bv t	"t%b(2)"	\-
pop(b[2])	t	"t"	"t%b(2) = 3.5"
push(s)	s \(bv t	"t%s"	\-
pop(s)	t	"t"	"t%s = 'a','b','c'"
.TE
.DE
.P
\fISbuf_t\fP actually contains two parallel string representations,
One string is called the \fIlrep\fP,
the \fILua representation\fP of the current table element.
The second is the \fIfrep\fP,
or \fIFortran representation\fP.
They are identical except for the component separator ('.' or '%')
and details of indexing for array values.
The \fIfrep\fP is shown in the table above.
The \fIlrep\fP is convenient for pattern matching and error reporting,
while the \fIfrep\fP is required as input to the assignment parser.
.P
Here is the signature of \fIiir_read\fP:
.DS
.VB
int iir_read(lua_State *L, sbuf_t *sb, char *fp, char *lp, int sh);
.VE
.DE
.P
The \fIsb\fP pointer keeps track of the left end of the \fIfrep\fP
and \fIlrep\fP (which never change),
while the \fIfp\fP and \fIlp\fP pointers keep track of the right
end (the trailing \f[CR]'\\0'\fP) of those strings.
The \fIsh\fP argument is a boolean,
indicating whether
the special handling table should be searched on this invocation.
It is normally \fITRUE\fP (non-zero),
but may be turned off during the processing of a special handler
function.
.P
There is only one Lua stack,
passed from one invocation of \fIiir_read\fP to the next.
In the same sense,
there is only one \fIfrep\fP and \fIlrep\fP,
which grow and shrink on their right end as we descend into
or ascend out of a Lua table.
To reiterate, the pointers \fIfp\fP and \fIlp\fP track the right,
not left,
ends of those strings.
The \fIfrep\fP and \fIlrep\fP are just normal C character arrays,
but we manipulate them as if they were stacks:
Each invocation of \fIiir_read\fP uses \fIfp\fP and \fIlp\fP
as the current ``top of string pointer.''
This is a little unusual in C/C++ programming,
but it simplifies the string processing in this case.
(One extra step is that each time \fIiir_read\fP returns,
we must explicitly restore the trailing '\\0' character in \fIfrep\fP
and \fIlrep\fP.)
.\" ======================================================================
.H 2 "Reading a String Value"
.P
The most complicated code in the IR front end is that
devoted to handling string valued input variables.
The ISO_C_BINDING requires that we represent strings as
arrays of characters in C/C++ and Fortran.
So a scalar Lua string value is stored in a one dimensional array of
characters in the IR back end,
and a vector of ``strings'' is a two dimensional character
array in the back end.
Let's compare a Lua input string with its output to the
assignment parser for scalar and vector examples:
.DS
.VB
Lua input string    Output to parser
----------------    ----------------
a.b.s    = "foo"    "a%b%s       = 'f','o','o'" // Scalar, part 1
                    "a%b%s(4:  ) = 2048*' '"    // Scalar, part 2

a.b.v[2] = "foo"    "a%b%v( :,2) = 'f','o','o'" // Vector, part 1
                    "a%b%v(4:,2) = 2048*' '"    // Vector, part 2
.VE
.DE
In both cases,
the string \fIvalue\fP (right hand side)
is rewritten for the parser as a literal array of single characters.
For the scalar case,
part 1 is otherwise fairly simple:
Change the component separator from '.' to '%'.
IREP adds a terminating null character at the end of the non-blank
portion of the string value.
Then (part 2) we blank fill the right end of the string,
using the original string length (3\(pl1\(eq4 in the example)
to compute where the blanks begin.
The vector case is a little harder:
We have to construct a two-dimensional Fortran reference,
exchange the indices,
assign the array of single character values,
then blank fill the right end,
beginning at the string length\(pl1.
(The ':' character in the examples is standard Fortran array syntax.)
Part 2 in each case always overfills the IR back end storage for the
string with blanks.
``2048'' is the declared length of the \fIfrep\fP and \fIlrep\fP buffers,
the maximum length of any single string value.
More precisely,
the Fortran \fIread namelist\fP statement blank fills the back end
string variable to its actual declared limit,
then stops and returns a non-zero (error) status,
which is ignored by the IR front end.
The front end does not know the actual size of any back end variables.
.P
Dealing with numbers or boolean values is much easier.
.\" ======================================================================
.H 1 "The Back End in Detail"
.P
The back end is a set of statically declared structured variables.
These variables are constructed from a single source form,
using C preprocessor macros defined in the file \fIir_macros.h\fP.
We follow the rules of the ISO_C_BINDING in constructing the variables,
so one instance can be shared between Fortran and C/C++.
The variables are organized into \fIwell known tables\fP,
one table in each of the several \fIwkt_*.h\fP files.
For our purposes,
a well known table is the name of a global table in the Lua input,
whose name and structure are shared with the host (compiled) codes.
.P
Within a given \fIwkt_*.h\fP file,
we follow the rules of C/C++ and Fortran so that
any subtables are declared in lexical order,
with the innermost scope first.
The definition/instantiation of the table is at the end
of the file.
.P
The back end variables have global scope by default.
However, it is easy to restrict their scope by
placing them in a namespace (\fIirep\fP is the default) for use by C++,
or to compile their content as a module,
for use by Fortran.
.P
Once built, the back end is trivial,
in the sense that the IR has no operations (other than \fIir_read\fP)
that affect it.
All other host code interaction with the back end is done
using explicit native language statements and expressions:
.DS
.VB
int my_a = irep::t.a; // Copy an IREP value to a local C++ variable.
.VE
.DE
.\" ======================================================================
.H 2 "String Values in the IR Back End"
.P
Strings are stored in the IR back end
as statically declared character arrays.
Therefore each one has a maximum length set at compile time.
They are delimited by a null character,
followed by zero or more blanks.
.P
Fortran can represent strings in two ways.
One is a \fIscalar\fP variable of type character,
with a specified maximum length.
The second is an \fIarray\fP of type character,
each element of which contains one character.
Each form is blank delimited,
although note that IREP adds a terminating null character.
.P
Sharing strings between Fortran and C/C++ using
the ISO_C_BINDING requires Fortran to use the second form.
Most Fortran character intrinsic functions operate on scalar strings,
not array-type strings.
.\" ======================================================================
.H 1 "The Assignment Parser in Detail"
.P
The assignment parser is contained in the file \fIir_readnml.h\fP,
and is short enough to include here in its entirety:
.DS
.VB
1   integer(c_int) function cir_rd(s,n) bind(c, name="ir_rd_nml")
2     integer(c_int), value, intent(in) :: n
3     character(len=1,kind=c_char), intent(in) :: s(n)
4     character(kind=c_char,len=n) :: fs
5     namelist /ir_input/ t ! For the table in Ex. 1.
6     fs = transfer(s,fs)
7     read(fs, nml=ir_input, iostat=cir_rd)
8   end function
.VE
.DE
.P
The Fortran function \fIcir_rd\fP is called only from
C routines within \fIirep.c\fP.
It takes two arguments: A character array \f[CB]s\fP,
and the length of the array \f[CB]n\fP.
The C caller usually will null-terminate the buffer;
this is irrelevant to \fIcir_rd\fP,
which uses only the passed array length.
The character array is compatible with the ISO_C_BINDING.
However, the Fortran \fIread\fP statement requires
a scalar character variable,
so we copy (line 6) the array argument to a
scalar temporary \f[CB]fs\fP (defined at line 4).
.P
Strings passed to a Fortran
\fIread namelist\fP statement require a particular structure.
Here is the first output from Ex. 1 above,
as it would be passed to \fIcir_rd\fP:
.DS
.VB
&ir_input t%a = 3 /
.VE
.DE
E.g., the string has a prefix ``&ir_input'',
which matches the namelist identifier at line 5 of the function,
and it has a final delimiter ``/''.
Line 5 is normally constructed by the build system,
and contains the names of all the well known tables for a given code.
Line 5 can be thought of as a \fIregistration\fP operation,
where we notify the compiler which variable names may be included in
later namelist reads.
For structured types,
it is sufficient to register only the top level table name.
Then all elements within that table are available to read later.
For example, registering just ``t'' as above means that any of
\fIt%a\fP, \fIt%b(1)\fP, \fIt%b(2)\fP, or \fIt%s\fP
could be read later on.
.\" ======================================================================
.H 1 "Special Handling"
.P
Most of the time,
Lua tables
containing ``plain old data''
can be easily and directly mapped into a structured
variable in the compiled code.
However, Lua tables are much more expressive than C/C++ or Fortran
structured variables.
Both keys and values in a Lua table can be any type.
Array elements can be a mixture of types.
It may sometimes be
desirable to design Lua input that cannot be
easily mapped into a structured variable in the IR back end.
A \fIspecial handler\fP function allows the Lua table designer to take
complete control over how certain table elements will be read by the IR.
The simplest special handler is very simple indeed:
.DS
.VB
int ir_ignore(lua_State *L,sbuf_t *sb,char *fp,char *lp) { return 0; }
.VE
.DE
.P
For this function,
the special handling table (see \fIir_special.h\fP)
might contain an entry such as:
.DS
.VB
{ "^foo.bar$",              ir_ignore },
.VE
.DE
.P
When the IR front end finds the \fIbar\fP key in the \fIfoo\fP table,
it executes \fIir_ignore\fP,
which silently does nothing at all.
The presumption here is that the host code will make separate provision
to read that particular value,
outside of IREP.
That separate reader can use the full power of the Lua library
to do whatever is necessary.
.P
Why does \fIir_ignore\fP have this effect?
Here is the relevant code,
located near the beginning of \fIiir_read\fP:
.DS
.VB
// Special handling requested for this item?
if (sh) {
  for(i=0; i < (int)(sizeof(sh_tbl)/sizeof(sh_tbl[0])); i++)
    if (match(sh_tbl[i].pat, sb->lrep) > 0)
      return sh_tbl[i].h(L, sb, fp, lp);
}
.VE
.DE
.P
The boolean \fIsh\fP is normally \fITRUE\fP,
so we execute the loop,
stepping through every entry in the special handling table
(linear search.)
We compare each pattern with the current value of \fIlrep\fP.
When the pattern (regular expression) "^foo.bar$" matches the
value of \fIlrep\fP "foo.bar",
we call the associated function \fIir_ignore\fP,
which happens to always return zero.
With that,
we are finished with the element so far as \fIiir_read\fP is concerned.
.P
A more complex example is the special handler for the Blast
\fIale_trigger\fP element.
This element specifies how to construct an instance of the
Blast \fIDTimer\fP class.
Lua input for an
\fIale_trigger\fP is an array that may
contain zero or more of any of three kinds of timers:
.DS
.VB
ale_trigger = {{ "times", { 2, 2.5, 4, 5, 6, 7.5, 8, 10 }}
ale_trigger = {{ "uniform", n=1, start=0, stop=5 }}
ale_trigger = {{ "timeslice", start=0, stop=5, delta=1, max=1 }}
.VE
.DE
.P
It would be difficult to map such varied input to a single
structured variable in the IR back end.
(The current Blast code uses a 133 line custom function to read
the Lua \fIale_trigger\fP specification.)
So the strategy in this case is to make an IR special handler that
stores a reference to the table,
allowing the host code to read it later with its custom function:
.DS
.VB
int ir_ale_trigger(lua_State *L, sbuf_t *sb, char *fp, char *lp)
{
  if ((lua_objlen(L,-1)) < 1) return 0; // Table is empty: ignore it.
  lua_pushinteger(L, luaL_ref(L, LUA_REGISTRYINDEX));
  return iir_read(L, sb, fp, lp, 0);
}
.VE
.DE
.P
When the \fIir_ale_trigger\fP special handler is invoked,
the element on top of the Lua stack is an array of one or more
of the three kinds of timers as shown above.
We check its length (\fIlua_objlen\fP).
The host code has a default handler if the table is empty,
so we can ignore that case (return 0.)
If the table is not empty, we store the table
in the Lua registry, create a reference (\fIluaL_ref\fP)
and push the reference onto the top of the stack (\fIlua_pushinteger\fP.)
The IR back end defines an \fIale_trigger\fP element as a simple scalar integer.
The special handler calls \fIiir_read\fP to read the integer reference
now on top of the stack into the back end slot for the \fIale_trigger\fP.
Note that we have to turn off the special handling flag for that
recursive call to \fIiir_read\fP.
.P
Later on, when the code needs the \fIale_trigger\fP,
it pulls the original table out of the Lua registry,
using the integer reference stored in the IR,
then calls the custom \fIDTimer::Read\fP function to parse the table.
The special handler here is only three lines,
but there is quite a bit of knowledge of the Lua C library,
the IR front end protocols,
and the IR back end slot for this particular element designed into it.
.\" ======================================================================
.H 1 "Lua Callback Functions"
.P
Lua callback functions are a standard IR element that effectively
receive special handling.
As such, most of the machinery for special handling is shared with
callback functions.
The table of callback functions in \fIir_special.h\fP is very
similar to the special handling table,
with the difference that the handler function for callbacks is
the same for all, so not included in the table \-
See \fIread_cb\fP in \fIirep.c\fP.
In addition to specifying a name pattern,
the callback function table specifies the number of parameters
(\fInprm\fP) and number of return values (\fInret\fP) for each
callback function.
These numbers are a guarantee from the host code to the Lua
programmer that their Lua callback function may use up to
\fInprm\fP arguments,
and that the host code will look for
no more than \fInret\fP return values.
In other words,
the Lua callback function could declare and/or use fewer than
\fInprm\fP arguments,
and could conceivably return more than \fInret\fP values,
without incurring a Lua language error.
.P
The IR presently defines only one ``kind'' of Lua callback function.
That is,
we assume that the function takes zero or more numeric (integer or
double) parameters,
and returns zero or more numeric (all double) values.
There is a standard structured variable type for this purpose in
\fIir_std.h\fP,
called a \fIlua_cb_dd_data\fP.
More kinds of Lua callback functions may be defined in the future.
.P
Handling a callback function in the IR front end is quite similar
to the \fIale_trigger\fP special handler discussed earlier.
The function itself is stored in the Lua registry;
its integer reference (the \fIfref\fP) is stored in the
associated \fIlua_cb_dd_data\fP variable.
The reference is used later on whenever the host code evaluates
the callback function.
.P
As an optimization,
and convenience to the user,
the code also allows functions to be defined in the Lua input
as a \fInumber\fP, or an array of up to 9 numbers.
This is interpreted as if it were a constant function,
but without actually calling a Lua function.
Instead,
the given numbers are stored directly in the \fIlua_cb_dd_data\fP variable.
.\" ======================================================================
.H 1 "Building the IREP"
.P
The IREP presents itself to a host code
as a set of \fIwell known tables\fP (WKT),
plus a library containing several functions.
Most of the code for the library is written in ``clean C'',
compileable by either a C or C++ compiler.
The assignment parser is a Fortran function,
so both C/C++ and Fortran compilers are required to build the IREP.
.P
A WKT named, e.g., ``table1'' is defined in a file named ``wkt_table1.h''.
For a C/C++ client,
the well known tables are included directly as header files:
.DS
.VB
#include "wkt_table1.h"
#include "wkt_table2.h"
.VE
.DE
For a Fortran client,
it is more convenient
(and gives better control of the namespace)
to use \fImodules\fP:
.DS
.VB
use wkt_table1
use wkt_table2
.VE
.DE
To produce a Fortran module,
the build process for a WKT converts the original header file to Fortran,
then compiles that source.
The C pre-processor does most of the work.
Here is a \fImake\fP pattern rule that
constructs Fortran source from WKT header files:
.DS
.VB
wkt_%.f : wkt_%.h ir_macros.h ir_start.h ir_end.h
	gcc -E -DIR_WKT_NAME=wkt_$* $(irep.cppflags) $< | \\
	sed -e 's/ *## *//' -e '/^#/d' -e '/^ *$$/d' > $@
.VE
.DE
Each WKT depends on its own source file,
and the definitions in \fIir_macros.h\fP,
\fIir_start.h\fP,
and \fIir_end.h\fP.
The \fIgcc\ -E\fP command runs just the preprocessor,
while the following \fIsed\fP command handles cleanup that
is necessary or convenient in some environments.
Once we have \fIwkt_table1.f\fP,
the Fortran compiler produces the module file
\fIwkt_table1.mod\fP and the object file \fIwkt_table1.o\fP.
.\" ======================================================================
.H 1 "Debugging"
.P
The IREP code is fairly small,
which simplifies debugging.
However,
the main function recursively builds and traverses several stack-oriented
data structures,
which complicates debugging.
One good strategy is to simply view the sequence of
strings sent from the front end table reader to the assignment parser.
Defining the macro \f[CI]IR_DEBUG\fP at compile time turns on this mechanism.
.\" ======================================================================
.H 1 "Limitations"
.P
The IREP was designed to bring together codes written in C/C++ and Fortran,
to share data read from a common set of Lua tables.
The limitations of IREP are largely a consequence of the original
design goals.
.AL
.LI
IREP stores ``plain old data'', strictly typed,
along with Lua callback functions that accept double precision
parameters and return double precision values.
.LI
There is an escape mechanism to store other things,
but it takes some work.
.LI
C/Fortran interoperability is limited to static objects:
Array sizes are defined at compile time;
.LI
Strings are neither fully ``C'' nor fully ``Fortran''.
(An equal opportunity annoyance.)
.LI
Names in the IR follow the Fortran rule of case insensitivity.
.LI
The data store (back end) has no introspection,
nor bulk operations.
.LI
From Lua's perspective,
the data store is ``write-only''.
.LI
You need both C/C++ and Fortran compilers to build IREP.
.LE
.\" ======================================================================
.H 1 "External Functions"
.H 2 "int ir_exists(lua_State *L, const char *s)"
Return \fItrue\fP (non-zero) if the Lua table element named in \fIs\fP
actually exists in the Lua state.
The string ``s'' is a fully qualified key in an IREP well known
table,
written in Lua syntax.
For example, using the table defined in Ex. 1,
we could say:
.VB
if (ir_exists(L, "t.a")) printf("We found t.a\\n");
.VE
.H 2 "int ir_nblen(char *s, int n)"
Return the number of non-blank characters in
the string \fIs\fP,
counting from the right.
This is used by the \fIIR_LEN\fP macro.
Again from Ex. 1:
.VB
#define IR_LEN(s) ir_nblen(s,(int)sizeof(s))
printf("Length of t.s = %d\\n", IR_LEN(t.s)); // 3 ("abc")
.VE
.H 2 "int ir_read(lua_State *L, const char *s)"
Return the number of errors in reading the Lua table,
or table element,
given in \fIs\fP.
.H 2 "int ir_rtlen(lua_State *L, const char *s)"
For the Lua object named in ``s'',
return the same value as would the Lua operator \fI#s\fP.
.TC
